# -*- coding: utf-8 -*-
"""power_Forecasting .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10JQjZUtMkz-xjX_avLUnEJESTARknpYo
"""

import streamlit as st
import pandas as pd
import numpy as np
import joblib
from datetime import datetime, timedelta
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import os

# ============================================================================
# CONFIGURATION & CONSTANTS
# ============================================================================

ITHD_RUL_THRESHOLD = 10.0
PF_RUL_THRESHOLD = 0.84
SOILING_LOSS_THRESHOLD = 0.10
PERFORMANCE_RATIO_MIN = 0.75

# System Specifications
SYSTEM_CONFIG = {
    'panel_capacity_kw': 5.0,
    'panel_area_m2': 25.0,
    'inverter_efficiency': 0.97,
    'system_efficiency': 0.85,
    'degradation_rate': 0.005,
    'location': 'Bangalore, India',
    'latitude': 12.9716,
    'longitude': 77.5946
}

# Weather condition impact factors
WEATHER_FACTORS = {
    'Clear Sky': 1.0,
    'Partly Cloudy': 0.7,
    'Cloudy': 0.4,
    'Rainy': 0.15
}

# ============================================================================
# MODEL LOADING
# ============================================================================

@st.cache_resource
def load_forecasting_system():
    """Load ML models and scalers."""
    try:
        if os.path.exists('solar_forecast_model.pkl'):
            model_data = joblib.load('solar_forecast_model.pkl')
            st.success(" ML Model loaded successfully!")
            return model_data
        else:
            st.warning(" Model file not found. Please run training script first:\npython solar_ml_training.py")
            return None
    except Exception as e:
        st.error(f" Error loading model: {str(e)}")
        return None

MODEL_DATA = load_forecasting_system()

# ============================================================================
# CORE PREDICTION FUNCTIONS
# ============================================================================

def estimate_irradiance(hour, month, day_of_year, weather_condition):
    """Estimate solar irradiance based on time, season, and weather."""
    if hour < 6 or hour > 18:
        return 0

    # Solar noon adjusted for Bangalore
    solar_noon = 12.5
    hour_angle = (hour - solar_noon) / 6.5
    base_irradiance = 1000 * np.exp(-2 * hour_angle**2)

    # Seasonal adjustment
    if month in [6, 7, 8, 9]:  # Monsoon
        seasonal_factor = 0.65
    elif month in [10, 11, 1, 2]:  # Winter
        seasonal_factor = 0.90
    else:  # Summer
        seasonal_factor = 0.85

    # Apply weather condition factor
    weather_factor = WEATHER_FACTORS.get(weather_condition, 1.0)

    return base_irradiance * seasonal_factor * weather_factor

def estimate_temperature(hour, day_of_year, current_temp):
    """Estimate ambient temperature based on time and user input."""
    # Use current temperature as base and add daily variation
    temp_daily = 5 * np.sin(2 * np.pi * (hour - 6) / 12)
    return current_temp + temp_daily

def estimate_humidity(month, day_of_year, current_humidity):
    """Estimate relative humidity."""
    # Use current humidity as base
    if month in [6, 7, 8, 9]:  # Monsoon - higher humidity
        return min(95, current_humidity + 10)
    return current_humidity

def simple_power_model(irradiance, panel_temp, weather_condition):
    """Physics-based power calculation model."""
    temp_loss = 1 - 0.004 * max(0, panel_temp - 25)

    # Additional weather-based soiling/dust factor
    if weather_condition == 'Rainy':
        soiling_factor = 0.95  # Rain cleans panels
    elif weather_condition == 'Cloudy':
        soiling_factor = 0.92
    elif weather_condition == 'Partly Cloudy':
        soiling_factor = 0.94
    else:
        soiling_factor = 0.90  # Clear sky - more dust accumulation

    power = (SYSTEM_CONFIG['panel_capacity_kw'] *
            (irradiance / 1000) *
            SYSTEM_CONFIG['system_efficiency'] *
            temp_loss *
            soiling_factor)

    return max(0, power)

def create_feature_vector(hour, doy, month, dow, weekend, irr, temp, panel_t, hum, hist_data):
    """Create feature vector for ML prediction."""
    hour_sin = np.sin(2 * np.pi * hour / 24)
    hour_cos = np.cos(2 * np.pi * hour / 24)
    day_sin = np.sin(2 * np.pi * doy / 365)
    day_cos = np.cos(2 * np.pi * doy / 365)

    # Use historical data for lag features
    if hist_data is not None and len(hist_data) > 0:
        power_24h_mean = hist_data['power_kw'].tail(24).mean() if len(hist_data) >= 24 else 0
        power_24h_max = hist_data['power_kw'].tail(24).max() if len(hist_data) >= 24 else 0
        irr_24h_mean = hist_data['irradiance'].tail(24).mean() if len(hist_data) >= 24 else 0
        power_lag_1h = hist_data['power_kw'].iloc[-1] if len(hist_data) >= 1 else 0
        power_lag_2h = hist_data['power_kw'].iloc[-2] if len(hist_data) >= 2 else 0
        power_lag_3h = hist_data['power_kw'].iloc[-3] if len(hist_data) >= 3 else 0
        power_lag_24h = hist_data['power_kw'].iloc[-24] if len(hist_data) >= 24 else 0
    else:
        power_24h_mean = power_24h_max = irr_24h_mean = 0
        power_lag_1h = power_lag_2h = power_lag_3h = power_lag_24h = 0

    return [
        hour, doy, month, dow, weekend,
        irr, temp, panel_t, hum,
        hour_sin, hour_cos, day_sin, day_cos,
        power_24h_mean, power_24h_max, irr_24h_mean,
        power_lag_1h, power_lag_2h, power_lag_3h, power_lag_24h
    ]

def predict_next_week(current_temp, current_humidity, weather_condition, historical_data):
    """
    Generate hour-by-hour predictions for the next 7 days.
    Now properly uses weather condition parameter.
    """
    predictions = []
    current_time = datetime.now()

    for hours_ahead in range(168):  # 7 days * 24 hours
        future_time = current_time + timedelta(hours=hours_ahead)

        # Extract temporal features
        hour = future_time.hour
        day_of_year = future_time.timetuple().tm_yday
        month = future_time.month
        day_of_week = future_time.weekday()
        is_weekend = int(day_of_week >= 5)

        # Estimate environmental conditions with weather impact
        irradiance = estimate_irradiance(hour, month, day_of_year, weather_condition)
        ambient_temp = estimate_temperature(hour, day_of_year, current_temp)
        panel_temp = ambient_temp + (irradiance / 1000) * 25
        humidity = estimate_humidity(month, day_of_year, current_humidity)

        # Predict power output
        if MODEL_DATA is not None and 'model' in MODEL_DATA:
            # Use ML model
            features = create_feature_vector(
                hour, day_of_year, month, day_of_week, is_weekend,
                irradiance, ambient_temp, panel_temp, humidity,
                historical_data
            )

            features_scaled = MODEL_DATA['scaler'].transform([features])
            power_pred = MODEL_DATA['model'].predict(features_scaled)[0]

            # Apply weather condition factor to ML prediction as well
            weather_factor = WEATHER_FACTORS.get(weather_condition, 1.0)
            power_pred = power_pred * weather_factor
        else:
            # Use physics-based model
            power_pred = simple_power_model(irradiance, panel_temp, weather_condition)

        # Calculate confidence interval
        uncertainty = 0.10 * power_pred

        predictions.append({
            'timestamp': future_time,
            'power_kw': max(0, power_pred),
            'power_lower': max(0, power_pred - uncertainty),
            'power_upper': max(0, power_pred + 1.5 * uncertainty),
            'irradiance': irradiance,
            'ambient_temp': ambient_temp,
            'panel_temp': panel_temp,
            'weather': weather_condition
        })

    return pd.DataFrame(predictions)

def calculate_performance_metrics(predictions_df):
    """Calculate key performance indicators."""
    daily_energy = predictions_df.groupby(predictions_df['timestamp'].dt.date)['power_kw'].sum()

    metrics = {
        'total_energy_7d': daily_energy.sum(),
        'daily_avg': daily_energy.mean(),
        'peak_power': predictions_df['power_kw'].max(),
        'capacity_factor': (daily_energy.sum() / (SYSTEM_CONFIG['panel_capacity_kw'] * 168)) * 100,
        'expected_revenue': daily_energy.sum() * 6.5,
        'daily_energies': daily_energy.tolist()
    }

    return metrics

# ============================================================================
# HISTORICAL DATA GENERATION
# ============================================================================

@st.cache_data
def load_or_generate_historical_data():
    """Load or generate recent historical data."""
    try:
        if os.path.exists('recent_solar_data.csv'):
            df = pd.read_csv('recent_solar_data.csv', parse_dates=['timestamp'])
            return df
    except:
        pass

    # Generate last 7 days of data
    data = []
    for hours_ago in range(168, 0, -1):
        ts = datetime.now() - timedelta(hours=hours_ago)
        hour = ts.hour
        doy = ts.timetuple().tm_yday
        month = ts.month

        irr = estimate_irradiance(hour, month, doy, 'Clear Sky')
        temp = estimate_temperature(hour, doy, 28)
        panel_t = temp + (irr / 1000) * 25
        power = simple_power_model(irr, panel_t, 'Clear Sky')

        data.append({
            'timestamp': ts,
            'power_kw': power,
            'irradiance': irr,
            'ambient_temp': temp,
            'panel_temp': panel_t
        })

    return pd.DataFrame(data)

# ============================================================================
# STREAMLIT UI
# ============================================================================

st.set_page_config(
    page_title="Solar Rooftop Power Forecaster",
    page_icon="‚òÄ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS
st.markdown("""
<style>
    .main-title {
        font-size: 2.8rem;
        font-weight: 800;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center;
        margin-bottom: 0.5rem;
    }
    .subtitle {
        text-align: center;
        color: #666;
        font-size: 1.1rem;
        margin-bottom: 2rem;
    }
    .metric-card {
        background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
        border-radius: 15px;
        padding: 1.5rem;
        border-left: 5px solid #667eea;
        box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }
    .section-header {
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 12px;
        font-size: 1.4rem;
        font-weight: 700;
        margin: 2rem 0 1.5rem 0;
        box-shadow: 0 4px 10px rgba(102,126,234,0.3);
    }
    .info-badge {
        display: inline-block;
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-weight: 600;
        font-size: 0.9rem;
        margin: 0.3rem;
    }
    .badge-excellent { background: #d4edda; color: #155724; }
    .badge-good { background: #d1ecf1; color: #0c5460; }
    .badge-warning { background: #fff3cd; color: #856404; }
</style>
""", unsafe_allow_html=True)

# Header
st.markdown('<h1 class="main-title"> Solar Rooftop Power Forecasting System</h1>', unsafe_allow_html=True)
st.markdown(f'<p class="subtitle"> {SYSTEM_CONFIG["location"]} | {SYSTEM_CONFIG["panel_capacity_kw"]}kW System | IEC 61724-1 Compliant</p>', unsafe_allow_html=True)

# Sidebar
with st.sidebar:
    
    st.title(" System Configuration")

    st.markdown("### System Specifications")
    st.info(f"""
    *Panel Capacity:* {SYSTEM_CONFIG['panel_capacity_kw']} kW
    *Panel Area:* {SYSTEM_CONFIG['panel_area_m2']} m¬≤
    *System Efficiency:* {SYSTEM_CONFIG['system_efficiency']*100:.0f}%
    *Inverter Efficiency:* {SYSTEM_CONFIG['inverter_efficiency']*100:.1f}%
    """)

    st.markdown("### Current Conditions")
    current_temp = st.slider("Ambient Temperature (¬∞C)", 20, 45, 28, key='temp_slider')
    current_humidity = st.slider("Relative Humidity (%)", 30, 95, 65, key='humidity_slider')
    weather_condition = st.selectbox(
        "Weather Forecast",
        ["Clear Sky", "Partly Cloudy", "Cloudy", "Rainy"],
        key='weather_select'
    )

    # Display weather impact
    weather_impact = WEATHER_FACTORS[weather_condition] * 100
    if weather_impact == 100:
        st.success(f" {weather_condition}: {weather_impact:.0f}% solar efficiency")
    elif weather_impact >= 70:
        st.info(f" {weather_condition}: {weather_impact:.0f}% solar efficiency")
    elif weather_impact >= 40:
        st.warning(f" {weather_condition}: {weather_impact:.0f}% solar efficiency")
    else:
        st.error(f" {weather_condition}: {weather_impact:.0f}% solar efficiency")

    st.markdown("---")

    if st.button(" Refresh Forecast", use_container_width=True, key='refresh_btn'):
        st.cache_data.clear()
        st.rerun()

    st.caption(f"Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

# Load historical data
historical_data = load_or_generate_historical_data()

# Generate 7-day forecast
with st.spinner(" Generating 7-day power forecast..."):
    forecast_df = predict_next_week(current_temp, current_humidity, weather_condition, historical_data)
    metrics = calculate_performance_metrics(forecast_df)

# ============================================================================
# KEY METRICS DASHBOARD
# ============================================================================

st.markdown('<div class="section-header"> 7-Day Forecast Summary</div>', unsafe_allow_html=True)

col1, col2, col3, col4, col5 = st.columns(5)

with col1:
    st.metric(
        "Total Energy",
        f"{metrics['total_energy_7d']:.1f} kWh",
        delta=f"{metrics['daily_avg']:.1f} kWh/day"
    )

with col2:
    st.metric(
        "Daily Average",
        f"{metrics['daily_avg']:.1f} kWh",
        delta=None
    )

with col3:
    st.metric(
        "Peak Power",
        f"{metrics['peak_power']:.2f} kW",
        delta=f"{(metrics['peak_power']/SYSTEM_CONFIG['panel_capacity_kw']*100):.0f}% capacity"
    )

with col4:
    cf = metrics['capacity_factor']
    st.metric(
        "Capacity Factor",
        f"{cf:.1f}%",
        delta="Excellent" if cf > 20 else "Good" if cf > 15 else "Low"
    )

with col5:
    st.metric(
        "Est. Revenue",
        f"‚Çπ{metrics['expected_revenue']:.0f}",
        delta="@ ‚Çπ6.5/kWh"
    )

# ============================================================================
# HOURLY POWER FORECAST CHART
# ============================================================================

st.markdown('<div class="section-header">‚ö° Hour-by-Hour Power Forecast (7 Days)</div>', unsafe_allow_html=True)

fig_hourly = go.Figure()

# Confidence interval
fig_hourly.add_trace(go.Scatter(
    x=forecast_df['timestamp'],
    y=forecast_df['power_upper'],
    fill=None,
    mode='lines',
    line=dict(width=0),
    showlegend=False,
    hoverinfo='skip'
))

fig_hourly.add_trace(go.Scatter(
    x=forecast_df['timestamp'],
    y=forecast_df['power_lower'],
    fill='tonexty',
    mode='lines',
    line=dict(width=0),
    name='Confidence Interval (90%)',
    fillcolor='rgba(102, 126, 234, 0.2)',
    hoverinfo='skip'
))

# Main prediction line
fig_hourly.add_trace(go.Scatter(
    x=forecast_df['timestamp'],
    y=forecast_df['power_kw'],
    mode='lines',
    name='Predicted Power',
    line=dict(color='#667eea', width=3),
    hovertemplate='<b>%{x|%a %d %b, %H:%M}</b><br>Power: %{y:.2f} kW<extra></extra>'
))

# System capacity line
fig_hourly.add_hline(
    y=SYSTEM_CONFIG['panel_capacity_kw'],
    line_dash="dash",
    line_color="red",
    annotation_text="System Capacity",
    annotation_position="right"
)

fig_hourly.update_layout(
    title=f"Predicted Power Output - Next 7 Days (Weather: {weather_condition})",
    xaxis_title="Date & Time",
    yaxis_title="Power Output (kW)",
    hovermode='x unified',
    height=450,
    template='plotly_white',
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
)

st.plotly_chart(fig_hourly, use_container_width=True)

# ============================================================================
# DAILY ENERGY FORECAST
# ============================================================================

st.markdown('<div class="section-header"> Daily Energy Production Forecast</div>', unsafe_allow_html=True)

daily_forecast = forecast_df.groupby(forecast_df['timestamp'].dt.date).agg({
    'power_kw': 'sum',
    'irradiance': 'mean',
    'panel_temp': 'max'
}).reset_index()
daily_forecast.columns = ['Date', 'Energy_kWh', 'Avg_Irradiance', 'Max_Panel_Temp']

col_chart, col_table = st.columns([2, 1])

with col_chart:
    fig_daily = go.Figure()

    fig_daily.add_trace(go.Bar(
        x=daily_forecast['Date'],
        y=daily_forecast['Energy_kWh'],
        name='Daily Energy',
        marker=dict(
            color=daily_forecast['Energy_kWh'],
            colorscale='Viridis',
            showscale=True,
            colorbar=dict(title="kWh")
        ),
        text=daily_forecast['Energy_kWh'].round(1),
        textposition='outside',
        hovertemplate='<b>%{x}</b><br>Energy: %{y:.1f} kWh<extra></extra>'
    ))

    fig_daily.update_layout(
        title="Daily Energy Production Forecast",
        xaxis_title="Date",
        yaxis_title="Energy (kWh)",
        height=400,
        template='plotly_white',
        showlegend=False
    )

    st.plotly_chart(fig_daily, use_container_width=True)

with col_table:
    st.markdown("#####  Daily Breakdown")

    display_df = daily_forecast.copy()
    display_df['Date'] = pd.to_datetime(display_df['Date']).dt.strftime('%a, %b %d')
    display_df['Energy_kWh'] = display_df['Energy_kWh'].round(1)
    display_df['Avg_Irradiance'] = display_df['Avg_Irradiance'].round(0).astype(int)
    display_df['Max_Panel_Temp'] = display_df['Max_Panel_Temp'].round(1)

    display_df.columns = ['Date', 'Energy (kWh)', 'Irradiance (W/m¬≤)', 'Max Temp (¬∞C)']

    st.dataframe(
        display_df,
        use_container_width=True,
        hide_index=True,
        height=350
    )

# ============================================================================
# WEATHER IMPACT COMPARISON
# ============================================================================

st.markdown('<div class="section-header">üå§ Weather Condition Impact Analysis</div>', unsafe_allow_html=True)

st.info(f"*Current Forecast:* {weather_condition} conditions for the next 7 days")

# Generate comparison data for all weather conditions
comparison_data = []
for weather in WEATHER_FACTORS.keys():
    temp_forecast = predict_next_week(current_temp, current_humidity, weather, historical_data)
    temp_metrics = calculate_performance_metrics(temp_forecast)
    comparison_data.append({
        'Weather': weather,
        'Total_Energy': temp_metrics['total_energy_7d'],
        'Daily_Avg': temp_metrics['daily_avg'],
        'Peak_Power': temp_metrics['peak_power'],
        'Revenue': temp_metrics['expected_revenue']
    })

comparison_df = pd.DataFrame(comparison_data)

# Weather comparison chart
fig_weather = go.Figure()

fig_weather.add_trace(go.Bar(
    x=comparison_df['Weather'],
    y=comparison_df['Total_Energy'],
    name='7-Day Total Energy',
    marker_color=['#4CAF50', '#FFC107', '#FF9800', '#F44336'],
    text=comparison_df['Total_Energy'].round(1),
    textposition='outside',
    hovertemplate='<b>%{x}</b><br>Energy: %{y:.1f} kWh<br>Revenue: ‚Çπ%{customdata:.0f}<extra></extra>',
    customdata=comparison_df['Revenue']
))

fig_weather.update_layout(
    title="Energy Production Under Different Weather Conditions",
    xaxis_title="Weather Condition",
    yaxis_title="Total Energy (kWh)",
    height=400,
    template='plotly_white',
    showlegend=False
)

st.plotly_chart(fig_weather, use_container_width=True)

# Comparison table
st.markdown("#####  Detailed Weather Impact Comparison")
comparison_display = comparison_df.copy()
comparison_display['Total_Energy'] = comparison_display['Total_Energy'].round(1)
comparison_display['Daily_Avg'] = comparison_display['Daily_Avg'].round(1)
comparison_display['Peak_Power'] = comparison_display['Peak_Power'].round(2)
comparison_display['Revenue'] = comparison_display['Revenue'].round(0)
comparison_display.columns = ['Weather', 'Total Energy (kWh)', 'Daily Avg (kWh)', 'Peak Power (kW)', 'Revenue (‚Çπ)']

st.dataframe(comparison_display, use_container_width=True, hide_index=True)

# ============================================================================
# ENVIRONMENTAL CONDITIONS FORECAST
# ============================================================================

st.markdown('<div class="section-header">üå° Environmental Conditions Forecast</div>', unsafe_allow_html=True)

tab1, tab2, tab3 = st.tabs(["‚òÄ Solar Irradiance", "üå° Temperature", " Combined Analysis"])

with tab1:
    fig_irr = go.Figure()

    fig_irr.add_trace(go.Scatter(
        x=forecast_df['timestamp'],
        y=forecast_df['irradiance'],
        fill='tozeroy',
        name='Solar Irradiance',
        line=dict(color='#ffd700', width=2),
        fillcolor='rgba(255, 215, 0, 0.3)',
        hovertemplate='<b>%{x|%a %d %b, %H:%M}</b><br>Irradiance: %{y:.0f} W/m¬≤<extra></extra>'
    ))

    fig_irr.add_hline(
        y=1000,
        line_dash="dash",
        line_color="orange",
        annotation_text="Peak Irradiance (1000 W/m¬≤)"
    )

    fig_irr.update_layout(
        title=f"Solar Irradiance Forecast ({weather_condition})",
        xaxis_title="Date & Time",
        yaxis_title="Irradiance (W/m¬≤)",
        height=400,
        template='plotly_white',
        hovermode='x unified'
    )

    st.plotly_chart(fig_irr, use_container_width=True)

    avg_irradiance = forecast_df[forecast_df['irradiance'] > 0]['irradiance'].mean()
    max_irradiance = forecast_df['irradiance'].max()

    st.info(f"""
    *Irradiance Statistics ({weather_condition}):*
    - *Average (daylight hours):* {avg_irradiance:.0f} W/m¬≤
    - *Peak:* {max_irradiance:.0f} W/m¬≤
    - *Efficiency Factor:* {WEATHER_FACTORS[weather_condition]*100:.0f}%

    Peak irradiance (1000 W/m¬≤) represents optimal clear sky conditions
    """)

with tab2:
    fig_temp = make_subplots(
        rows=2, cols=1,
        subplot_titles=('Ambient Temperature', 'Panel Temperature'),
        vertical_spacing=0.15
    )

    fig_temp.add_trace(
        go.Scatter(
            x=forecast_df['timestamp'],
            y=forecast_df['ambient_temp'],
            name='Ambient Temp',
            line=dict(color='#4CAF50', width=2),
            hovertemplate='<b>%{x|%a %d %b, %H:%M}</b><br>Ambient: %{y:.1f}¬∞C<extra></extra>'
        ),
        row=1, col=1
    )

    fig_temp.add_trace(
        go.Scatter(
            x=forecast_df['timestamp'],
            y=forecast_df['panel_temp'],
            name='Panel Temp',
            line=dict(color='#FF5722', width=2),
            fill='tozeroy',
            fillcolor='rgba(255, 87, 34, 0.2)',
            hovertemplate='<b>%{x|%a %d %b, %H:%M}</b><br>Panel: %{y:.1f}¬∞C<extra></extra>'
        ),
        row=2, col=1
    )

    # Optimal temperature range
    fig_temp.add_hrect(
        y0=20, y1=30,
        line_width=0,
        fillcolor="green",
        opacity=0.1,
        annotation_text="Optimal",
        annotation_position="right",
        row=1, col=1
    )

    fig_temp.update_xaxes(title_text="Date & Time", row=2, col=1)
    fig_temp.update_yaxes(title_text="Temperature (¬∞C)", row=1, col=1)
    fig_temp.update_yaxes(title_text="Temperature (¬∞C)", row=2, col=1)

    fig_temp.update_layout(
        height=600,
        template='plotly_white',
        hovermode='x unified',
        showlegend=True
    )

    st.plotly_chart(fig_temp, use_container_width=True)

    avg_panel_temp = forecast_df[forecast_df['power_kw'] > 0]['panel_temp'].mean()
    max_panel_temp = forecast_df['panel_temp'].max()
    temp_efficiency_loss = 0.4 * max(0, avg_panel_temp - 25)

    st.warning(f"""
    *Temperature Impact Analysis:*
    - *Average Panel Temp:* {avg_panel_temp:.1f}¬∞C
    - *Maximum Panel Temp:* {max_panel_temp:.1f}¬∞C
    - *Efficiency Loss:* ~{temp_efficiency_loss:.1f}% (due to temperature)

    Panel efficiency decreases by 0.4% per ¬∞C above 25¬∞C
    """)

with tab3:
    # Hourly average pattern
    hourly_avg = forecast_df.groupby(forecast_df['timestamp'].dt.hour).agg({
        'power_kw': 'mean',
        'irradiance': 'mean',
        'panel_temp': 'mean'
    }).reset_index()
    hourly_avg.columns = ['hour', 'power_kw', 'irradiance', 'panel_temp']

    fig_combined = make_subplots(specs=[[{"secondary_y": True}]])

    fig_combined.add_trace(
        go.Scatter(
            x=hourly_avg['hour'],
            y=hourly_avg['power_kw'],
            name='Avg Power',
            line=dict(color='#667eea', width=3),
            mode='lines+markers'
        ),
        secondary_y=False
    )

    fig_combined.add_trace(
        go.Scatter(
            x=hourly_avg['hour'],
            y=hourly_avg['irradiance'],
            name='Avg Irradiance',
            line=dict(color='#ffd700', width=2, dash='dash'),
            mode='lines'
        ),
        secondary_y=True
    )

    fig_combined.update_xaxes(title_text="Hour of Day")
    fig_combined.update_yaxes(title_text="Power (kW)", secondary_y=False)
    fig_combined.update_yaxes(title_text="Irradiance (W/m¬≤)", secondary_y=True)

    fig_combined.update_layout(
        title="Average Hourly Power vs Irradiance Pattern",
        height=400,
        template='plotly_white',
        hovermode='x unified'
    )

    st.plotly_chart(fig_combined, use_container_width=True)

    # Performance statistics
    st.markdown("#####  Performance Statistics")

    stat_col1, stat_col2, stat_col3 = st.columns(3)

    peak_hour_idx = hourly_avg['power_kw'].idxmax()
    peak_hour = hourly_avg.loc[peak_hour_idx, 'hour']
    avg_peak_power = hourly_avg['power_kw'].max()
    total_sunshine_hours = len(forecast_df[forecast_df['power_kw'] > 0.1]) / 7
    avg_efficiency = (metrics['total_energy_7d'] / (SYSTEM_CONFIG['panel_capacity_kw'] * 168)) * 100

    with stat_col1:
        st.markdown(f"""
        <div class="metric-card">
            <h4>‚òÄ Peak Production Hour</h4>
            <h2>{peak_hour:.0f}:00</h2>
            <p>Avg: {avg_peak_power:.2f} kW</p>
        </div>
        """, unsafe_allow_html=True)

    with stat_col2:
        st.markdown(f"""
        <div class="metric-card">
            <h4> Daily Sunshine Hours</h4>
            <h2>{total_sunshine_hours:.1f} hrs</h2>
            <p>Productive generation time</p>
        </div>
        """, unsafe_allow_html=True)

    with stat_col3:
        st.markdown(f"""
        <div class="metric-card">
            <h4> System Efficiency</h4>
            <h2>{avg_efficiency:.1f}%</h2>
            <p>Of installed capacity</p>
        </div>
        """, unsafe_allow_html=True)

# ============================================================================
# PERFORMANCE RATIO & SYSTEM HEALTH
# ============================================================================

st.markdown('<div class="section-header"> System Performance & Health Indicators</div>', unsafe_allow_html=True)

health_col1, health_col2 = st.columns(2)

with health_col1:
    st.markdown("#####  Performance Ratio (PR)")

    # Calculate PR (IEC 61724-1 standard)
    reference_yield = forecast_df['irradiance'].sum() / 1000
    actual_yield = metrics['total_energy_7d'] / SYSTEM_CONFIG['panel_capacity_kw']
    pr = (actual_yield / reference_yield) if reference_yield > 0 else 0
    pr_percentage = pr * 100

    # PR Status
    if pr_percentage >= 80:
        pr_status = "Excellent"
        pr_color = "#00c851"
        pr_badge = "badge-excellent"
    elif pr_percentage >= 75:
        pr_status = "Good"
        pr_color = "#33b5e5"
        pr_badge = "badge-good"
    else:
        pr_status = "Needs Attention"
        pr_color = "#ffbb33"
        pr_badge = "badge-warning"

    # PR Gauge Chart
    fig_pr = go.Figure(go.Indicator(
        mode="gauge+number+delta",
        value=pr_percentage,
        domain={'x': [0, 1], 'y': [0, 1]},
        title={'text': "Performance Ratio", 'font': {'size': 24}},
        delta={'reference': 80, 'increasing': {'color': "green"}},
        gauge={
            'axis': {'range': [None, 100], 'tickwidth': 1, 'tickcolor': "darkblue"},
            'bar': {'color': pr_color},
            'bgcolor': "white",
            'borderwidth': 2,
            'bordercolor': "gray",
            'steps': [
                {'range': [0, 75], 'color': '#ffcccb'},
                {'range': [75, 80], 'color': '#ffffcc'},
                {'range': [80, 100], 'color': '#ccffcc'}
            ],
            'threshold': {
                'line': {'color': "red", 'width': 4},
                'thickness': 0.75,
                'value': 75
            }
        }
    ))

    fig_pr.update_layout(height=300, margin=dict(l=20, r=20, t=50, b=20))
    st.plotly_chart(fig_pr, use_container_width=True)

    st.markdown(f'<div class="info-badge {pr_badge}">{pr_status} - PR: {pr_percentage:.1f}%</div>', unsafe_allow_html=True)

    st.info("""
    *IEC 61724-1 PR Standards:*
    - *>80%:* Excellent system performance
    - *75-80%:* Good performance
    - *<75%:* Investigation recommended
    """)

with health_col2:
    st.markdown("#####  System Health Checklist")

    health_checks = []

    # Capacity Factor
    if metrics['capacity_factor'] > 18:
        health_checks.append(("‚úÖ", "Capacity Factor", f"{metrics['capacity_factor']:.1f}%", "Excellent"))
    elif metrics['capacity_factor'] > 15:
        health_checks.append(("‚ö†", "Capacity Factor", f"{metrics['capacity_factor']:.1f}%", "Good"))
    else:
        health_checks.append(("‚ùå", "Capacity Factor", f"{metrics['capacity_factor']:.1f}%", "Low"))

    # Peak Power
    peak_achievement = (metrics['peak_power'] / SYSTEM_CONFIG['panel_capacity_kw']) * 100
    if peak_achievement > 90:
        health_checks.append(("‚úÖ", "Peak Power", f"{peak_achievement:.0f}%", "Optimal"))
    elif peak_achievement > 75:
        health_checks.append(("‚ö†", "Peak Power", f"{peak_achievement:.0f}%", "Acceptable"))
    else:
        health_checks.append(("‚ùå", "Peak Power", f"{peak_achievement:.0f}%", "Degraded"))

    # Temperature
    max_panel_temp = forecast_df['panel_temp'].max()
    if max_panel_temp < 60:
        health_checks.append(("‚úÖ", "Temperature", f"{max_panel_temp:.1f}¬∞C", "Normal"))
    elif max_panel_temp < 70:
        health_checks.append(("‚ö†", "Temperature", f"{max_panel_temp:.1f}¬∞C", "Elevated"))
    else:
        health_checks.append(("‚ùå", "Temperature", f"{max_panel_temp:.1f}¬∞C", "Critical"))

    # Consistency
    daily_std = np.std(metrics['daily_energies'])
    daily_cv = (daily_std / metrics['daily_avg']) * 100 if metrics['daily_avg'] > 0 else 0
    if daily_cv < 20:
        health_checks.append(("‚úÖ", "Consistency", f"{daily_cv:.1f}% CV", "Stable"))
    elif daily_cv < 30:
        health_checks.append(("‚ö†", "Consistency", f"{daily_cv:.1f}% CV", "Variable"))
    else:
        health_checks.append(("‚ùå", "Consistency", f"{daily_cv:.1f}% CV", "Unstable"))

    health_df = pd.DataFrame(health_checks, columns=['Status', 'Parameter', 'Value', 'Assessment'])
    st.dataframe(health_df, use_container_width=True, hide_index=True)

    # Recommendations
    st.markdown("##### Recommendations")

    recommendations = []
    if pr_percentage < 75:
        recommendations.append("‚Ä¢ Clean solar panels - possible soiling detected")
    if peak_achievement < 80:
        recommendations.append("‚Ä¢ Check for shading or panel degradation")
    if max_panel_temp > 65:
        recommendations.append("‚Ä¢ Improve panel ventilation")
    if daily_cv > 25:
        recommendations.append("‚Ä¢ Investigate weather-related losses")
    if weather_condition == "Rainy":
        recommendations.append("‚Ä¢ Good time for natural panel cleaning!")

    if recommendations:
        for rec in recommendations:
            st.warning(rec)
    else:
        st.success("‚úÖ All systems operating within normal parameters")



# ============================================================================
# EXPORT DATA
# ============================================================================

st.markdown('<div class="section-header"> Export Forecast Data</div>', unsafe_allow_html=True)

export_col1, export_col2, export_col3 = st.columns(3)

with export_col1:
    export_df = forecast_df[['timestamp', 'power_kw', 'power_lower', 'power_upper',
                               'irradiance', 'ambient_temp', 'panel_temp']].copy()
    export_df.columns = ['Timestamp', 'Power_kW', 'Lower_Bound_kW', 'Upper_Bound_kW',
                          'Irradiance_W_m2', 'Ambient_Temp_C', 'Panel_Temp_C']

    csv_data = export_df.to_csv(index=False)

    st.download_button(
        label=" Download Hourly Forecast (CSV)",
        data=csv_data,
        file_name=f"solar_forecast_{datetime.now().strftime('%Y%m%d')}.csv",
        mime="text/csv",
        use_container_width=True
    )

with export_col2:
    daily_summary_csv = daily_forecast.to_csv(index=False)

    st.download_button(
        label=" Download Daily Summary (CSV)",
        data=daily_summary_csv,
        file_name=f"solar_daily_{datetime.now().strftime('%Y%m%d')}.csv",
        mime="text/csv",
        use_container_width=True
    )

with export_col3:
    if st.button(" Regenerate Forecast", use_container_width=True):
        st.cache_data.clear()
        st.rerun()

# Footer
st.markdown("---")
st.markdown(f"""
<div style='text-align: center; color: #666; padding: 1.5rem;'>
    <p style='font-size: 1.1rem;'><strong> Solar Rooftop Power Forecasting System</strong></p>
    <p style='font-size: 0.9rem;'>Compliant with IEC 61724-1 Standards | Weather-Aware ML Predictions</p>
    <p style='font-size: 0.85rem; color: #999;'>
        Current Weather: {weather_condition} ({WEATHER_FACTORS[weather_condition]*100:.0f}% efficiency) |
        System: {SYSTEM_CONFIG['panel_capacity_kw']:.1f}kW Rooftop<br>
        Model Status: {'ML Model Active' if MODEL_DATA else 'Physics-Based Model (Fallback)'}
    </p>
</div>
""", unsafe_allow_html=True)

# ============================================================================
# ENVIRONMENTAL BENEFITS
# ============================================================================

st.markdown('<div class="section-header">üå± Environmental Benefits</div>', unsafe_allow_html=True)

# Calculate CO2 saved and equivalent trees planted
CO2_SAVED_KG = metrics['total_energy_7d'] * 0.82  # kg CO2 per kWh
TREES_EQUIVALENT = CO2_SAVED_KG / 21.77

col_env1, col_env2 = st.columns(2)

with col_env1:
    st.metric(
        "CO‚ÇÇ Emissions Saved",
        f"{CO2_SAVED_KG:.1f} kg",
        delta=None
    )

with col_env2:
    st.metric(
        "Equivalent Trees Planted",
        f"{TREES_EQUIVALENT:.1f}",
        delta=None
    )

st.caption("Estimates based on Indian grid average (0.82 kg CO‚ÇÇ/kWh) and annual absorption per tree (~21.77 kg CO‚ÇÇ/tree/year).")
